# 第1节：基础知识

### 

+ ### Java的特点以及与C++的不同

  Java语言为完全面向对象的语言，支持封装、继承与多态，不存在独立的方法和变量，同时具有跨平台的特点，由JVM完成class文件的解释，并提供垃圾回收机制进行内存管理。此外，相比于C++，Java没有指针概念，采用封装后的引用概念，保证内存访问的安全性。同时，Java的类为单继承，而C++为多继承，为了弥补这一问题，Java提供接口的多继承。为了保证代码的健壮性，Java语言提供了更为完善的异常处理机制，此外，并提供了反射机制，保证语言的灵活性。

+ ### Java基本类型

  | 基本类型 | 包装类型  | 大小  |
  | :------: | :-------: | :---: |
  |   byte   |   Byte    | 1字节 |
  |  short   |   Short   | 2字节 |
  |   char   | Charactor | 2字节 |
  |   int    |  Integer  | 4字节 |
  |   long   |   Long    | 8字节 |
  |  float   |   Float   | 4字节 |
  |  double  |  Double   | 8字节 |
  | boolean  |  Boolean  |   -   |

+ ### 自动装箱和拆箱

  Java是完全面向对象的语言，为了保持基本编程习惯提供了数据基本类型，但是在一些情况下无法使用基本数据类型，如向集合Collection只能传递引用对象，此时需要将基本类型转换为对象，因此为了代码简练，Java1.5引入了自动装箱和拆箱机制。

  自动装箱：将基本类型用对应的引用类型包装起来；编译器调用valueOf( )将原始数据转换为对象；

  自动拆箱：将包装类型转换为基本数据类型；编译器通过调用xxxValue( )方法将对象转换为原始类型值；

  **常见问题：Integer对象的装箱问题**

  ```java
  Integer i1 = 100;
  Integer i2 = 100;
  Integer i3 = 200;
  Integer i4 = 200;
  
  System.out.println(i1 == i2) // 打印true
  System.out.println(i3 == i4) // 打印false
  ```

  原因是，通过valueOf创建Integer对象时，如果数值在[-128, 127]之间，便返回指向IntegerCache.cache中已经存在的对象引用，否则创建一个新的对象。

  Integer的valueOf方法的具体实现：

  ```java
  public static Integer valueOf(int i) {
          if(i >= -128 && i <= IntegerCache.high)
              return IntegerCache.cache[i + 128];
          else
              return new Integer(i);
  }
  ```

  其中，IntegerCache类的实现为：

  ```java
  private static class IntegerCache {
          static final int high;
          static final Integer cache[];
  
          static {
              final int low = -128;
              // high value may be configured by property
              int h = 127;
              if (integerCacheHighPropValue != null) {
                  // Use Long.decode here to avoid invoking methods that
                  // require Integer's autoboxing cache to be initialized
                  int i = Long.decode(integerCacheHighPropValue).intValue();
                  i = Math.max(i, 127);
                  // Maximum array size is Integer.MAX_VALUE
                  h = Math.min(i, Integer.MAX_VALUE - -low);
              }
              high = h;
              cache = new Integer[(high - low) + 1];
              int j = low;
              for(int k = 0; k < cache.length; k++)
                  cache[k] = new Integer(j++);
          }
          private IntegerCache() {}
  }
  ```

+ ### == 与 equals() 的区别

  **==**： 基本类型比较的是值，引用类型比较的是内存地址，此时判断的是两个对象是不是同一个对象；

  **equals( )**：判断两个对象是不是相等；Object类的equals方法返回的是“==”比较结果，因此自定义类需要重写该方法实现判断对象内容的相等；

  