# 第8节：JVM



### Java虚拟机内存

![](https://ww1.sinaimg.cn/large/007rAy9hgy1g1kwu556gij30ip0cymy9.jpg)

+ 程序计数器

  记录当前线程所执行的字节码的行号指示，为线程私有的，每个线程都有一个独立的程序计数器。

+ Java虚拟机栈

  描述的是Java方法执行的内存模型，为线程私有，生命周期与线程相同，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。该区域包括两个异常：

  1、StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度；

  2、OutOfMemoryError：虚拟机栈无法申请到足够的内存；

+ 本地方法栈

  本地方法栈为虚拟机用到的Native方法服务。

+ Java堆

  Java堆是被所有线程共享，主要用于存储对象实例，是垃圾收集器主要管理的区域，被称为GC堆。

+ 方法区

  用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等数据。方法区包含运行时常量池，用于存放编译期生成的各种字面量和符号引用。

### OutOfMemoryError（OOM）异常

+ Java堆的溢出

  不断创建对象，并保证GC Roots对象之间有可达路径避免垃圾回收机制的清除，在对象数量达到最大堆的容量限制时就会出现内存溢出异常。

  ```java
  public class HeapOOM{
      
  	static class OOMObject{
      }
      
      public static void main(String[] args){
          List<OOMObject> list = new ArrayList<>();
          while(true){
              list.add(new OOMObject());
          }
      }
  }
  ```

+ 虚拟机栈和本地方法栈溢出

  HotSpot虚拟机不区分虚拟机栈和本地方法栈，单线程递归调用会出现StackOverflowError异常。

  ```java
  public class JavaVMStackSOF{
      
      private int stackLength = 1;
      
      public void stackLeak(){
          stackLength++;
          stackLeak();
      }
      
      public static void main(String[] args) throws Throwable{
          JavaVMStackSOF oom = new JavaVMStackSOF();
          try{
              oom.stackLeak();
          }catch(Throwable e){
              System.out.println(oom.stackLength);
              thow e;
          }
      }
  }
  ```

+ 方法区和运行时常量池溢出

  String.intern( )是一个Native方法，作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的Sting对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。

  ```java
  public class RuntimeConstantPoolOOM{
      
      public static void main(String[] args){
          List<String> list = new ArrayList<>();
          int i = 0;
          while(true){
              list.add(String.valueOf(i++).intern);
          }
      }
  }
  ```

### 垃圾收集器与内存分配策略

#### 判断对象是否存活

+ 引用计数法

  给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就时不可能再被使用。

  **不被主流使用的原因是无法解决对象间相互循环引用的问题。**

+ 可达性分析法

  通过GC Root对象作为起始点，开始向下搜索，搜索所走过的路径为引用链，当一个对象到GC Root没有任何引用链相连时，说明此对象不可用。要真正宣告对象死亡，需要经过两次标记过程：

  1. 如果对象在进行可达性分析后发现没有与GC Root相连接的引用链，那它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize( )方法。当对象没有覆盖finalize( )方法，或者finalize( )方法已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行。
  2. 如果这个对象被判定为有必要执行finalize( )方法，那么这个对象将会放置在一个叫做F-Queue队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize( )线程去执行它。finalize( )方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中对象进行第二次小规模的标记，如果对象要在finalize( )中成功拯救自己—只要重新与引用链的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将会移除出“即将回收”的集合；

  **Java中，GC Root包括：**

  1. 虚拟机栈中引用的对象；
  2. 方法区中类静态属性引用的对象；
  3. 方法区中常量引用的对象；
  4. 本地方法栈中JNI引用的对象；

+ 判断对象存活与“引用”的关系

  Java对引用概念进行了扩展，将引用分为强引用、软引用、弱引用和虚引用。

  1. **强引用**：就是程序代码中普遍存在的，类似“Object obj = new Object( )”这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
  2. **软引用**：用来描述一些还有用但是并非必须的对象。在系统将要发生内存溢出异常时，将会把这些对象列入回收范围中进行第二次回收。
  3. **弱引用**： 用户描述非必须对象的。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
  4. **虚引用**：一个对象是否有虚引用存在，完全不会对其他生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。

  #### 垃圾回收算法

  + 标记-清除算法

    最基础的收集算法，分为“标记”和“清除”两个阶段：

    1. 首先标记出所有需要回收的对象；
    2. 在标记完成后统一回收所有被标记的对象；

    **不足**：

    **效率问题： 标记和清除两个过程效率不高**

    **空间问题：标记清除之后产生大量不连续的内存碎片，空间碎片过多会导致分配大对象时，无法找到足够的连续内存而触发GC。**

  + 复制算法

    将可用内存按容量分为大小相等的两块，每次只使用其中一块。当一块内存使用完了，就将存活的对象复制到另一个上面，然后再把已使用的内存空间清理掉。

    **优点**：实现简单，运行高效；

    **缺点**：内存缩小为原来的一半，当对象存活率较高时，需要进行较多的复制操作，效率会变低；

    该方法主要用来回收新生代，由于新生代对象98%对象是“朝生夕死”，因此只需将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中存活的对象一次性的复制到另一块Survivor对象上，清理掉Eden和刚才使用的Survivor空间。默认Eden和Survivor空间的大小比例为8:1。

  + 标记-整理算法

    根据老年代的特点，提出标记-整理算法，标记过程与标记-清除一样，但后续是让存活的对象向一段移动，然后直接清理掉边界以外的内存。

  + 分代收集算法

    一般把Java堆分为新生代和老年代，根据各个年代的特点采用适当的收集算法。

    在新生代中，每次垃圾收集时都发现大批对象死去，只有少量存活，所以选用复制算法；

    在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，必须采用标记-清除或标记-整理算法；

  + 垃圾回收机制的一些知识

    1）JVM中的年代

    JVM中分为年轻代和老年代。一般情况下，新创建的对象会被分配到Eden区，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当在年龄增加一定时间时，就会被移到年老代中。

    大对象直接进入老年代，大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。

    2）Minor GC和Full GC的区别

    Minor GC：指发生在新生代的垃圾收集动作，该动作非常频繁。

    Full GC/Major GC：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。

    3）空间分配担保

    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以确保安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则将尝试进行一次MInor GC，尽管Minor GC是有风险的。如果小于或者没有设置允许担保，则进行一次Full GC。

  #### 垃圾收集器

  + CMS（Concurrent Mark Sweep）收集器

    CMS收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现。整体过程分为4个步骤：

    1)  初始标记：标记下GC Root能直接关联到的对象，需要Stop the world；

    2）并发标记：进行GC Roots Tracing的过程；

    3）重新标记：修正并发标记阶段因为用户程序运行产生变动的对象标记，也需要Stop the world；

    4）并发清除

    整体上耗时最长的阶段并发标记和并发清除是和用户线程一起工作的。

    ![](https://ww1.sinaimg.cn/large/007rAy9hly1g1m15undocj30cu064aa5.jpg)

  **缺点**：

  ​	1）CMS收集器对CPU资源非常敏感。

  ​	2）CMS收集器无法处理浮动垃圾，并发清除阶段用户线程还在运行，伴随产生新的垃圾，此时这部分垃圾并未标记，需要下次GC清除。

  ​	3) CMS是基于标记-清除算法实现的收集器，所以会产生大量空间碎片。

  + G1收集器

    一款面向服务端应用的垃圾收集器。

    **特点**：

    ​	1）并行与并发：能充分利用多CPU，多核环境缩短Stop the world停顿时间，同时可以通过并发的方式让Java程序继续运行。

    ​	2）分代收集

    ​        3）空间整合：G1整体上采用基于“标记-整理”算法实现收集器；

     			      G2从局部上采用“复制”算法实现；

    ​	4）可预测停顿：使用G1收集器，Java堆被划分为多个大小相等的独立区域。G1跟踪各个Region里面的垃圾堆积价值大小，在后代维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

    G1的大致运作步骤划分为：

    + 初始标记：只是标记下GC Root直接关联的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户线程并发运行，能在正确可用的Region中创建对象，这个阶段需要线程停顿；

    + 并发标记：从GC Root开始对堆中对象进行可达性分析，找到存活的对象，与用户线程并发执行；

    + 最终标记：修正在并发标记期间因用户程序继续运作而造成标记发生变化的那一部分标记记录；

    + 筛选回收：对各个Region区域的回收价值和成本进行排序，根据用户期望制定GC停顿时间来制定回收计划；

      

  ### 虚拟机类加载机制

  #### 定义

  把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中，验证、准备和解析3个部分统称为连接（Linking）。

  ![](https://ww1.sinaimg.cn/large/007rAy9hly1g1m28zbuafj30kh05u3zn.jpg)

  其中，加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，而解析阶段则不一定：在某些情况下，可以在初始化完成后再开始，这是为了支持Java语言运行时绑定。

  #### 触发类加载的条件

  1）遇到new，getstatic，putstatic或者invokestatic字节码指令时，如果没有初始化，需要先触发初始化。

  2）使用java.lang.reflect包的方法对类进行发射调用时。

  3）当初始化一个类时，发现其父类还没有进行过初始化，则需要发出父类的初始化。

  4）虚拟机启动时，用户指定要执行的主类，虚拟机会先初始化这个主类。

  5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.Methodhandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。

  #### 类的加载过程

  + **加载**

    1）通过一个类的全限定名来获取定义此类的二进制字节流；

    2）将这个字节流所代表的静态存储结构转换为方法区内运行时数据结构；

    3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

  + **验证**

    是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全，主要包括下面几个方面：

    1）文件格式验证

    2）元数据验证

    3）字节码验证

    4）符号引用验证

  + **准备**

    准备阶段是正式为类变量分配内存并设置类变量初始值阶段，这些变量所使用的内存都将在方法区中分配。这里只包括类变量（被static修饰的变量），初始值通常情况下是数据类型的零值。如果类字段属性表中存在ConstantValue属性（static final修饰），那么在准备阶段变量的值会被初始化为指定的值。

  + **解析**

    虚拟机将常量池中符号引用替换为直接引用的过程。

  + **初始化**

    类加载过程的最后一步，初始化阶段是执行类构造器<clinit>( )方法的过程。<clinit>( )方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，同时虚拟机保证子类的<clinit>( )方法执行前，父类的<clinit>( )方法已经执行完毕。

    简单来说，初始化就是对类变量进行赋值及执行静态代码块。

  #### 类加载器

  类加载器主要实现将类class文件读入内存，并为之创建一个java.lang.Class对象。而比较两个类是否相等，只有在两个类是同一个类加载器加载的前提下才有意义。

  + **类加载器分类**

    1）启动类加载器（Bootstrap ClassLoader）: 由C++实现，负责加载Java核心类；

    2）扩展类加载器（Extension ClassLoader）：负责加载Java扩展的核心类之外的类；

    3）应用程序类加载器（Application ClassLoader）: 负责加载用户类路径（ClassPath）上的指定类库；

    4）自定义类加载器：由Java语言实现，继承自抽象类ClassLoader。

  + **双亲委派模型**

    ![](https://ww1.sinaimg.cn/large/007rAy9hly1g1m4onjsafj30fq0fjq38.jpg)

  工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父类加载器去完成，依次向上，因此所有的类加载请求最终都会应该被传递到顶层的启动类加载器中，只有当父类加载器在它的搜索范围中没有找到所需要的类时，即无法完成该类加载，子加载器才会尝试自己去加载该类。

  这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar包，无论哪个类加载器加载该类，最终都会由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽然能正常编译，但不会被加载运行，保证不会出现混乱。

  + **双亲委派模型的代码实现**

    ClassLoader中loadClass方法实现了双亲委派模型

    ```java
    protected synchronized Class<?> loadClass(String name, boolean resolve) 
        throws ClassNotFoundException {
        
        //首先检查该类是否被加载
        Class c = findLoadedClass(name);
        if(c == null){
            //如果该类未加载
            try{
                if(parent != null){
                    //当父类加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                }else{
                    //当父类的加载器为空，则调用启动类加载器加载该类
                    c = findBootstrapClassOrNull(name);
                }
            }catch(ClassNotFoundException e){
                //非空父类加载器无法找到相应的类，则抛出异常
            }
            if(c == null){
                //如果父类加载器无法加载时，再调用findClass方法加载该类
                c = findClass(name);
            }
        }
        if(resolve){
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
    ```

    整体流程：

    先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass方法，若父加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出ClassNotFoundExcption异常，再调用自己的findClass( )方法进行加载。

    

  ### Java内存模型

  ![](https://ww1.sinaimg.cn/large/007rAy9hgy1g1m5poro1uj30ev08ct8y.jpg)

  Java内存模型的目的是屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。

  Java内存模型规定了所有的变量都存储在主内存中。每个线程都还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值）都必须在工作内存中进行，而不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

  Java内存模型中定义了8种操作来完成主内存与工作内存间交互，而且每种操作都是原子的、不可再分的。

  |      类型      |                             作用                             |
  | :------------: | :----------------------------------------------------------: |
  |  lock（锁定）  |    作用于主内存的变量，把一个变量标识为一条线程独占的状态    |
  | unlock（解锁） |     作用于主内存的变量，把一个处于锁定状态的变量释放出来     |
  |  read（读取）  | 作用于主内存的变量，把一个变量的值从主内存传输到工作内存中，以便随后的load使用 |
  |  load（载入）  | 作用于工作内存的变量，把read操作从主内存中得到的变量值放入到工作内存的变量副本中 |
  |  use（使用）   | 作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将执行这个操作 |
  | assign（赋值） | 作用于工作内存的变量，把一个从执行引擎中接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码操作时执行这个操作 |
  | store（存储）  | 作用于工作内存的变量，把工作内存中一个变量的值传递到主内存中，以使随后的write操作使用 |
  | write（写入）  | 作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中 |

###编译器优化

取余或者StringBuilder和StringBuffer





